package bgs.protocol.session.v1;
import "bgs/low/pb/client/account_types.proto";
import "bgs/low/pb/client/rpc_types.proto";
import "bgs/low/pb/client/session_types.proto";


message CreateSessionRequest {
	optional .bgs.protocol.account.v1.Identity identity = 1;
	optional fixed32 platform = 2;
	optional fixed32 locale = 3;
	optional string client_address = 4;
	optional int32 application_version = 5;
	optional string user_agent = 6;
	optional bytes session_key = 7;
	optional .bgs.protocol.session.v1.SessionOptions options = 8;
	optional bool requires_mark_alive = 9 [default = false];
}

message CreateSessionResponse {
	optional string session_id = 1;
}

message UpdateSessionRequest {
	optional .bgs.protocol.account.v1.Identity identity = 1;
	optional .bgs.protocol.session.v1.SessionOptions options = 2;
}

message DestroySessionRequest {
	optional .bgs.protocol.account.v1.Identity identity = 1;
	optional string session_id = 2;
}

message GetSessionCapacityRequest {
}

message GetSessionCapacityResponse {
	optional uint32 sessions_available = 1;
	optional uint32 time_frame_seconds = 2;
}

message GetSessionStateByBenefactorRequest {
	optional .bgs.protocol.account.v1.GameAccountHandle benefactor_handle = 1;
	optional bool include_billing_disabled = 2 [default = false];
}

message GetSessionStateByBenefactorResponse {
	optional .bgs.protocol.account.v1.GameAccountHandle benefactor_handle = 1;
	repeated .bgs.protocol.session.v1.SessionState session = 2;
}

message MarkSessionsAliveRequest {
	repeated .bgs.protocol.session.v1.SessionIdentifier session = 1;
}

message MarkSessionsAliveResponse {
	repeated .bgs.protocol.session.v1.SessionIdentifier failed_session = 1;
}

message GetSessionStateRequest {
	optional .bgs.protocol.account.v1.GameAccountHandle handle = 1;
	optional bool include_billing_disabled = 2 [default = false];
}

message GetSessionStateResponse {
	optional .bgs.protocol.account.v1.GameAccountHandle handle = 1;
	optional .bgs.protocol.session.v1.SessionState session = 2;
}

message SessionCreatedNotification {
	optional .bgs.protocol.account.v1.Identity identity = 1;
	optional uint32 reason = 2;
	optional string session_id = 3;
}

message SessionDestroyedNotification {
	optional .bgs.protocol.account.v1.Identity identity = 1;
	optional uint32 reason = 2;
	optional string session_id = 3;
}

message SessionUpdatedNotification {
	optional .bgs.protocol.account.v1.Identity identity = 1;
	optional uint32 reason = 2;
	optional string session_id = 3;
}

service SessionListener {
	rpc OnSessionCreated (.bgs.protocol.session.v1.SessionCreatedNotification) returns (.bgs.protocol.NO_RESPONSE);
	rpc OnSessionDestroyed (.bgs.protocol.session.v1.SessionDestroyedNotification) returns (.bgs.protocol.NO_RESPONSE);
	rpc OnSessionUpdated (.bgs.protocol.session.v1.SessionUpdatedNotification) returns (.bgs.protocol.NO_RESPONSE);
}

service SessionService {
	rpc CreateSession (.bgs.protocol.session.v1.CreateSessionRequest) returns (.bgs.protocol.session.v1.CreateSessionResponse);
	rpc DestroySession (.bgs.protocol.session.v1.DestroySessionRequest) returns (.bgs.protocol.NoData);
	rpc UpdateSession (.bgs.protocol.session.v1.UpdateSessionRequest) returns (.bgs.protocol.NoData);
	rpc GetSessionCapacity (.bgs.protocol.session.v1.GetSessionCapacityRequest) returns (.bgs.protocol.session.v1.GetSessionCapacityResponse);
	rpc GetSessionStateByBenefactor (.bgs.protocol.session.v1.GetSessionStateByBenefactorRequest) returns (.bgs.protocol.session.v1.GetSessionStateByBenefactorResponse);
	rpc MarkSessionsAlive (.bgs.protocol.session.v1.MarkSessionsAliveRequest) returns (.bgs.protocol.session.v1.MarkSessionsAliveResponse);
	rpc GetSessionState (.bgs.protocol.session.v1.GetSessionStateRequest) returns (.bgs.protocol.session.v1.GetSessionStateResponse);
}
