syntax = "proto3";
package io.casperlabs.casper.protocol;

import "empty.proto";
import "annotations.proto";

// If you are building for other languages "scalapb.proto" can be manually obtained here:
// https://raw.githubusercontent.com/scalapb/ScalaPB/master/protobuf/scalapb/scalapb.proto
// make a scalapb directory in this file's location and place it inside

import "scalapb.proto";

option (scalapb.options) = {
    package_name: "io.casperlabs.casper.protocol"
    flat_package: true
};

// --------- DeployService  --------
service DeployService {
    rpc DoDeploy (DeployData) returns (DeployServiceResponse) {
        option (google.api.http) = {
            put: "/deploy"
            body: "*"
        };
    }

    rpc createBlock (google.protobuf.Empty) returns (DeployServiceResponse) {
        option (google.api.http) = {
            post: "/block"
            body: "*"
        };
    }

    rpc showBlock (BlockQuery) returns (BlockQueryResponse) {
        option (google.api.http) = {
            put: "/show/block"
            body: "*"
        };
    }

    // Get dag
    rpc visualizeDag(VisualizeDagQuery) returns (VisualizeBlocksResponse) {
        option (google.api.http) = {
            put: "/show/dag"
            body: "*"
        };
    }

    rpc showMainChain (BlocksQuery) returns (stream BlockInfoWithoutTuplespace) {
        option (google.api.http) = {
            put: "/show/chain"
            body: "*"
        };
    }

    rpc showBlocks (BlocksQuery) returns (stream BlockInfoWithoutTuplespace) {
        option (google.api.http) = {
            put: "/show/blocks"
            body: "*"
        };
    }

    rpc findBlockWithDeploy (FindDeployInBlockQuery) returns (BlockQueryResponse) {
        option (google.api.http) = {
            put: "/find"
            body: "*"
        };
    }

    rpc queryState (QueryStateRequest) returns (QueryStateResponse) {
        option (google.api.http) = {
            put: "/query"
            body: "*"
        };
    }
}

message QueryStateRequest {
    string block_hash = 1; //base-16 encoding of block hash
    string key_variant = 2; //one of "hash", "uref", "address"
    string key_bytes = 3; //base-16 encoding of key
    string path = 4; // '/'-separated path of human-readable names to value
}

message QueryStateResponse {
    //TODO: should mimic ipc version
    string result = 1;
}

message DeployCode {
    bytes code = 1; // wasm byte code
    bytes args = 2; // ABI-encoded arguments
}

message DeployData {
    bytes address = 1; // length 20 bytes
    int64 timestamp = 2;
    DeployCode session = 3;
    DeployCode payment = 4;
    int64 gas_limit = 5;
    int64 gas_price = 6;
    int64 nonce = 7;
    string sig_algorithm = 8; // name of the algorithm used for signing
    bytes signature = 9; // signature over hash of [(hash(session code), hash(payment code), nonce, timestamp, gas limit, gas rate)]
    bytes user = 10; //public key
}

message BlockRequest {
    //Fields are redundant to allow for validity check.
    //Such a check can definitively distinguish this
    //from other message types with similar serializations.
    string base16Hash = 1;
    bytes hash = 2;
}

message ForkChoiceTipRequest {

}

message FindDeployInBlockQuery {
    bytes user = 1;
    int64 timestamp = 2;
}

message BlockQuery {
    string hash = 1;
}

message BlocksQuery {
    int32 depth = 1;
}

message DeployServiceResponse {
    bool success = 1;
    string message = 2;
}

message MaybeBlockMessage {
    BlockMessage block = 1;
}

message BlockQueryResponse {
    string status = 1;
    BlockInfo blockInfo = 2;
}

message VisualizeDagQuery {
    int32 depth                 = 1;
    bool showJustificationLines = 2;
}

message VisualizeBlocksResponse {
    string content = 1;
}

message DataWithBlockInfo {
    //TODO
    //    repeated Par postBlockData = 1;
    BlockInfoWithoutTuplespace block = 2;
}

message ContinuationsWithBlockInfo {
    repeated WaitingContinuationInfo postBlockContinuations = 1;
    BlockInfoWithoutTuplespace block = 2;
}

message WaitingContinuationInfo {
    //TODO
    //    repeated BindPattern postBlockPatterns = 1;
    //    Par postBlockContinuation = 2;
}

message BlockInfoWithoutTuplespace {
    string blockHash = 1;
    string blockSize = 2;
    int64 blockNumber = 3;
    int64 protocolVersion = 4;
    int32 deployCount = 5;
    string tupleSpaceHash = 6; // Same as postStateHash of BlockMessage
    int64 timestamp = 7;
    float faultTolerance = 8;
    string mainParentHash = 9;
    repeated string parentsHashList = 10;
    string sender = 11;
}

// For node clients, see BlockMessage for actual Casper protocol Block representation
message BlockInfo {
    string blockHash = 1;
    string blockSize = 2;
    int64 blockNumber = 3;
    int64 protocolVersion = 4;
    int32 deployCount = 5;
    string tupleSpaceHash = 6; // Same as postStateHash of BlockMessage
    string tupleSpaceDump = 7;
    int64 timestamp = 8;
    float faultTolerance = 9;
    string mainParentHash = 10;
    repeated string parentsHashList = 11;
    string sender = 12;
    string shardId = 13;
}

message PrivateNamePreviewQuery {
    bytes user = 1; // public key a la DeployData
    int64 timestamp = 2; // millisecond timestamp
    int32 nameQty = 3; // how many names to preview? (max: 1024)
}

message PrivateNamePreviewResponse {
    repeated bytes ids = 1; // a la GPrivate
}

// --------- End DeployService  --------

// ---------- Signing Protocol ---------
message ApprovedBlockCandidate {
    BlockMessage block = 1;
    int32 requiredSigs = 2;
}

message UnapprovedBlock {
    ApprovedBlockCandidate candidate = 1;
    int64 timestamp = 2;
    int64 duration = 3;
}

message Signature {
    bytes publicKey = 1;
    string algorithm = 2;
    bytes sig = 3;
}

message BlockApproval {
    ApprovedBlockCandidate candidate = 1;
    Signature sig = 2;
}

message ApprovedBlock {
    ApprovedBlockCandidate candidate = 1;
    repeated Signature sigs = 2;
}

message ApprovedBlockRequest {
    string identifier = 1;
}

message NoApprovedBlockAvailable {
    string identifier = 1;
    string nodeIdentifer = 2;
}

// ------- End Signing Protocol --------

// --------- Core Protocol  --------
message BlockMessage {
    bytes blockHash = 1; // obtained by hashing the information in the header
    Header header = 2;
    Body body = 3;
    repeated Justification justifications = 4; // map of all validators to latest blocks based on current view
    bytes sender = 5; // public key of the validator that created the block
    int32 seqNum = 6; // number of blocks created by the validator
    bytes sig = 7; // signature generated by signing `hash(hash(justification) concat blockHash)`.
    string sigAlgorithm = 8; // name of the algorithm used to sign
    string shardId = 9; // identifier of the shard where the block was created
    bytes extraBytes = 10;
}

message BlockMetadataInternal {
    // This message in mapped to a different Scala class because of protobuf's inability to create map<bytes, int64> for
    // bonds.
    option (scalapb.message).type = "io.casperlabs.models.BlockMetadata";

    bytes blockHash                       = 1;
    repeated bytes parents                = 2 [(scalapb.field).collection_type="collection.immutable.List"];
    bytes sender                          = 3;
    repeated Justification justifications = 4 [(scalapb.field).collection_type="collection.immutable.List"];
    repeated Bond bonds                   = 5 [(scalapb.field).collection_type="collection.immutable.List"];
    int64 blockNum                        = 6;
    int32 seqNum                          = 7;
}

message Header {
    repeated bytes parentsHashList = 1; //list of parent block hashes
    bytes postStateHash = 2;
    bytes deploysHash = 3;
    int64 timestamp = 5;
    int64 protocolVersion = 6;
    int32 deployCount = 7;
    bytes extraBytes = 8;
}

message ProcessedDeploy {
    DeployData deploy = 1;
    //TODO PCost previously
    uint64 cost = 2;
    bool errored = 3; //true if deploy encountered a user error
}

message Body {
    RChainState state = 1;
    repeated ProcessedDeploy deploys = 2;
    bytes extraBytes = 3;
}

message Justification {
    bytes validator = 1;
    bytes latestBlockHash = 2;
}

message RChainState {
    bytes preStateHash = 1; //hash of the tuplespace contents before new deploys
    bytes postStateHash = 2; //hash of the tuplespace contents after new deploys

    //Internals of what will be the "blessed" PoS contract
    //(which will be part of the tuplespace in the real implementation).
    repeated Bond bonds = 3;
    int64 blockNumber = 4;
}

message Event {
    oneof event_instance {
        ProduceEvent produce = 1;
        ConsumeEvent consume = 2;
        CommEvent comm = 3;
    }
}

message ProduceEvent {
    bytes channelsHash = 1;
    bytes hash = 2;
    int32 sequenceNumber = 3;
}

message ConsumeEvent {
    repeated bytes channelsHashes = 1;
    bytes hash = 2;
    int32 sequenceNumber = 3;
}

message CommEvent {
    ConsumeEvent consume = 1;
    repeated ProduceEvent produces = 2;
}

message Bond {
    bytes validator = 1;
    int64 stake = 2;
}
// --------- End Core Protocol  --------

// Technical message for mapping to new gossip structure.
message BodyHashes {
    bytes deploysHash = 1;
    bytes stateHash = 2;
}
